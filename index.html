<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2 Player Tank Battle</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1c2833, #2e4053);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
            color: white;
        }

        canvas {
            display: block;
            background-color: #34495e;
            border: 4px solid #5d6d7e;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
        }

        .game-container {
            position: relative;
        }

        .health-bar-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            border: 3px solid #5d6d7e;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            width: 150px;
        }

        .health-bar-label {
            margin-bottom: 5px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .health-bar-wrapper {
            width: 100%;
            height: 20px;
            background-color: #444;
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #555;
        }

        .health-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        #tank1-health-container {
            top: 20px;
            left: 20px;
        }

        #tank2-health-container {
            top: 20px;
            right: 20px;
        }

        #tank1-health {
            background-color: #2ecc71;
        }

        #tank2-health {
            background-color: #e74c3c;
        }

        #game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.7);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px 30px;
            border-radius: 10px;
            display: none;
        }

        #restart-button {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: #3498db;
            border: none;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            display: none;
            font-size: 16px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        #restart-button:hover {
            background-color: #2980b9;
        }

        .explosion {
            position: absolute;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div class="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="tank1-health-container" class="health-bar-container">
        <div class="health-bar-label">GREEN TANK</div>
        <div class="health-bar-wrapper">
            <div id="tank1-health" class="health-bar"></div>
        </div>
    </div>
    
    <div id="tank2-health-container" class="health-bar-container">
        <div class="health-bar-label">RED TANK</div>
        <div class="health-bar-wrapper">
            <div id="tank2-health" class="health-bar"></div>
        </div>
    </div>
    
    <div id="game-message"></div>
    <button id="restart-button">PLAY AGAIN</button>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const tank1HealthBar = document.getElementById('tank1-health');
    const tank2HealthBar = document.getElementById('tank2-health');
    const gameMessage = document.getElementById('game-message');
    const restartButton = document.getElementById('restart-button');

    // Set canvas dimensions
    canvas.width = Math.min(window.innerWidth * 0.8, 1000);
    canvas.height = Math.min(window.innerHeight * 0.8, 700);

    const gridSize = 50;
    let obstacles = [];
    let bullets = [];
    let explosions = [];
    let gameOver = false;
    
    // Game state
    let tank1, tank2;
    
    // Initialize game
    function initGame() {
        // Reset game state
        obstacles = [];
        bullets = [];
        explosions = [];
        gameOver = false;
        
        // Hide UI elements
        gameMessage.style.display = "none";
        restartButton.style.display = "none";
        
        // Initialize tanks
        tank1 = {
            x: 100,
            y: 100,
            width: 40,
            height: 50,
            speed: 4,
            rotation: 0,
            color: '#2ecc71',
            borderColor: '#145a32',
            flashCount: 0,
            health: 100,
            maxHealth: 100,
            shootCooldown: 0,
            maxCooldown: 15,
            barrelLength: 30,
            barrelWidth: 8,
            id: 1
        };

        tank2 = {
            x: canvas.width - 140,
            y: canvas.height - 140,
            width: 40,
            height: 50,
            speed: 4,
            rotation: 180,
            color: '#e74c3c',
            borderColor: '#7b241c',
            flashCount: 0,
            health: 100,
            maxHealth: 100,
            shootCooldown: 0,
            maxCooldown: 15,
            barrelLength: 30,
            barrelWidth: 8,
            id: 2
        };
        
        createObstacles();
        updateHealthBars();
    }

    // Create obstacles for the game map
    function createObstacles() {
        const rows = Math.floor(canvas.height / gridSize);
        const cols = Math.floor(canvas.width / gridSize);
        
        // Keep edges of map clear
        const clearEdgeSize = 3;
        
        // Main cover blocks
        for (let i = 0; i < 8; i++) {
            let validPosition = false;
            let x, y;
            
            while (!validPosition) {
                x = clearEdgeSize + Math.floor(Math.random() * (cols - 2 * clearEdgeSize));
                y = clearEdgeSize + Math.floor(Math.random() * (rows - 2 * clearEdgeSize));
                
                // Check if position is clear from tanks
                const tank1Clear = Math.hypot((x * gridSize) - tank1.x, (y * gridSize) - tank1.y) > 150;
                const tank2Clear = Math.hypot((x * gridSize) - tank2.x, (y * gridSize) - tank2.y) > 150;
                
                validPosition = tank1Clear && tank2Clear && 
                    !obstacles.some(o => Math.abs(o.x - x * gridSize) < gridSize && Math.abs(o.y - y * gridSize) < gridSize);
            }
            
            // Create a cluster of obstacles
            createObstacleCluster(x, y);
        }
    }
    
    // Create cluster of obstacles
    function createObstacleCluster(startX, startY) {
        // Center obstacle
        obstacles.push({ 
            x: startX * gridSize, 
            y: startY * gridSize,
            width: gridSize,
            height: gridSize
        });
        
        // Random neighboring obstacles
        const directions = [
            {dx: 1, dy: 0}, {dx: -1, dy: 0},
            {dx: 0, dy: 1}, {dx: 0, dy: -1}
        ];
        
        directions.forEach(dir => {
            if (Math.random() < 0.6) {
                const nx = startX + dir.dx;
                const ny = startY + dir.dy;
                
                // Ensure obstacle is within canvas
                if (nx >= 0 && nx * gridSize < canvas.width - gridSize && 
                    ny >= 0 && ny * gridSize < canvas.height - gridSize) {
                    obstacles.push({ 
                        x: nx * gridSize, 
                        y: ny * gridSize,
                        width: gridSize,
                        height: gridSize
                    });
                }
            }
        });
    }

    // Draw grid and obstacles
    function drawGrid() {
        // Draw grid lines
        ctx.strokeStyle = '#5d6d7e';
        ctx.lineWidth = 1;
        
        for (let x = 0; x < canvas.width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        
        for (let y = 0; y < canvas.height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        // Draw obstacles
        obstacles.forEach(obstacle => {
            // Fill
            ctx.fillStyle = '#717d7e';
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            
            // Thick outline
            ctx.strokeStyle = '#4d5656';
            ctx.lineWidth = 4;
            ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            
            // Inner details
            ctx.fillStyle = '#616a6b';
            ctx.fillRect(obstacle.x + 10, obstacle.y + 10, obstacle.width - 20, obstacle.height - 20);
        });
    }

    const keys = {
        w: false,
        a: false,
        s: false,
        d: false,
        ArrowUp: false,
        ArrowLeft: false,
        ArrowDown: false,
        ArrowRight: false,
        " ": false,
        Enter: false,
    };

    window.addEventListener('keydown', (e) => {
        if (keys[e.key] !== undefined) {
            keys[e.key] = true;
            e.preventDefault(); // Prevent default behavior (scrolling)
        }
    });

    window.addEventListener('keyup', (e) => {
        if (keys[e.key] !== undefined) {
            keys[e.key] = false;
        }
    });
    
    restartButton.addEventListener('click', () => {
        initGame();
    });

    function updateTankMovement(tank, controls) {
        // Store previous position
        const prevX = tank.x;
        const prevY = tank.y;
        
        // Handle rotation
        if (controls.a) {
            tank.rotation -= 3;
        }
        if (controls.d) {
            tank.rotation += 3;
        }
        
        // Normalize rotation
        tank.rotation = (tank.rotation + 360) % 360;
        
        // Calculate movement based on rotation
        let moveX = 0;
        let moveY = 0;
        
        if (controls.w) {
            moveX = tank.speed * Math.cos(tank.rotation * Math.PI / 180);
            moveY = tank.speed * Math.sin(tank.rotation * Math.PI / 180);
        }
        if (controls.s) {
            moveX = -tank.speed * Math.cos(tank.rotation * Math.PI / 180);
            moveY = -tank.speed * Math.sin(tank.rotation * Math.PI / 180);
        }
        
        // Try horizontal movement first
        tank.x += moveX;
        
        // Check collisions horizontal
        if (checkCollisionWithObstacles(tank) || checkCollisionWithTank(tank)) {
            tank.x = prevX; // Revert x movement
        }
        
        // Try vertical movement
        tank.y += moveY;
        
        // Check collisions vertical
        if (checkCollisionWithObstacles(tank) || checkCollisionWithTank(tank)) {
            tank.y = prevY; // Revert y movement
        }
        
        // Ensure tank stays within boundaries
        tank.x = Math.max(0, Math.min(canvas.width - tank.width, tank.x));
        tank.y = Math.max(0, Math.min(canvas.height - tank.height, tank.y));
    }

    function checkCollision(rect1, rect2) {
        // AABB collision detection with rotation compensation
        return (
            rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y
        );
    }

    function checkCollisionWithObstacles(tank) {
        for (const obstacle of obstacles) {
            if (checkCollision(tank, obstacle)) {
                return true;
            }
        }
        return false;
    }

    function checkCollisionWithTank(tank) {
        let targetTank = (tank.id === 1) ? tank2 : tank1;
        return checkCollision(tank, targetTank);
    }

    function drawTank(tank) {
        ctx.save();
        ctx.translate(tank.x + tank.width / 2, tank.y + tank.height / 2);
        ctx.rotate(tank.rotation * Math.PI / 180);

        // Determine tank color (flash if hit)
        let tankColor = tank.color;
        if (tank.flashCount > 0 && tank.flashCount % 2 === 0) {
            tankColor = 'white';
        }
        
        // Draw tank body (rectangle with thick outline)
        ctx.fillStyle = tankColor;
        ctx.fillRect(-tank.width / 2, -tank.height / 2, tank.width, tank.height);
        
        // Draw thick outline
        ctx.strokeStyle = tank.borderColor;
        ctx.lineWidth = 5;
        ctx.strokeRect(-tank.width / 2, -tank.height / 2, tank.width, tank.height);
        
        // Draw tank gun/barrel
        ctx.fillStyle = tankColor;
        ctx.fillRect(0, -tank.barrelWidth / 2, tank.barrelLength, tank.barrelWidth);
        ctx.strokeRect(0, -tank.barrelWidth / 2, tank.barrelLength, tank.barrelWidth);
        
        // Draw tank details
        ctx.fillStyle = tank.borderColor;
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    function shoot(tank) {
        if (tank.shootCooldown > 0 || gameOver) return;
        
        tank.shootCooldown = tank.maxCooldown;

        // Calculate bullet starting position at the end of barrel
        const bulletX = tank.x + tank.width / 2 + 
            (tank.barrelLength + 5) * Math.cos(tank.rotation * Math.PI / 180);
        const bulletY = tank.y + tank.height / 2 + 
            (tank.barrelLength + 5) * Math.sin(tank.rotation * Math.PI / 180);

        const bullet = {
            x: bulletX,
            y: bulletY,
            width: 6,
            height: 6,
            rotation: tank.rotation,
            speed: 10,
            tankId: tank.id,
            damage: 10
        };
        
        bullets.push(bullet);
    }

    function updateBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            
            // Update bullet position
            bullet.x += bullet.speed * Math.cos(bullet.rotation * Math.PI / 180);
            bullet.y += bullet.speed * Math.sin(bullet.rotation * Math.PI / 180);

            // Check if bullet is out of bounds
            if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                bullets.splice(i, 1);
                continue;
            }

            // Check collision with tanks and obstacles
            let hit = false;
            
            // Get the shooter and target tanks
            const shooterTank = bullet.tankId === 1 ? tank1 : tank2;
            const targetTank = bullet.tankId === 1 ? tank2 : tank1;
            
            // Check collision with target tank
            if (checkCollision(bullet, targetTank)) {
                targetTank.health -= bullet.damage;
                targetTank.flashCount = 10;
                
                // Create explosion effect
                createExplosion(bullet.x, bullet.y);
                
                if (targetTank.health <= 0) {
                    targetTank.health = 0;
                    endGame(shooterTank.id);
                }
                
                updateHealthBars();
                hit = true;
            }
            
            // Check collision with obstacles
            for (const obstacle of obstacles) {
                if (checkCollision(bullet, obstacle)) {
                    createExplosion(bullet.x, bullet.y);
                    hit = true;
                    break;
                }
            }
            
            // Remove bullet if it hit something
            if (hit) {
                bullets.splice(i, 1);
            }
        }
    }

    function createExplosion(x, y) {
        explosions.push({
            x: x,
            y: y,
            radius: 5,
            maxRadius: 20,
            opacity: 1,
            growth: 2
        });
    }
    
    function updateExplosions() {
        for (let i = explosions.length - 1; i >= 0; i--) {
            const explosion = explosions[i];
            
            // Grow the explosion
            explosion.radius += explosion.growth;
            explosion.opacity -= 0.05;
            
            // Remove faded explosions
            if (explosion.opacity <= 0) {
                explosions.splice(i, 1);
            }
        }
    }
    
    function drawExplosions() {
        explosions.forEach(explosion => {
            const gradient = ctx.createRadialGradient(
                explosion.x, explosion.y, 0,
                explosion.x, explosion.y, explosion.radius
            );
            
            gradient.addColorStop(0, `rgba(255, 255, 100, ${explosion.opacity})`);
            gradient.addColorStop(0.4, `rgba(255, 120, 40, ${explosion.opacity * 0.8})`);
            gradient.addColorStop(1, `rgba(255, 20, 20, ${explosion.opacity * 0.1})`);
            
            ctx.beginPath();
            ctx.fillStyle = gradient;
            ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function drawBullet(bullet) {
        ctx.save();
        ctx.translate(bullet.x, bullet.y);
        ctx.rotate(bullet.rotation * Math.PI / 180);
        
        // Draw bullet
        const bulletColor = bullet.tankId === 1 ? '#2ecc71' : '#e74c3c';
        ctx.fillStyle = bulletColor;
        ctx.beginPath();
        ctx.arc(0, 0, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw trail
        const gradient = ctx.createLinearGradient(-10, 0, 0, 0);
        gradient.addColorStop(0, 'rgba(255, 255, 0, 0)');
        gradient.addColorStop(1, bulletColor);
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        ctx.lineTo(0, 0);
        ctx.stroke();
        
        ctx.restore();
    }

    function updateHealthBars() {
        tank1HealthBar.style.width = (tank1.health / tank1.maxHealth * 100) + '%';
        tank2HealthBar.style.width = (tank2.health / tank2.maxHealth * 100) + '%';
        
        // Update health bar colors based on health level
        if (tank1.health < 30) {
            tank1HealthBar.style.backgroundColor = '#e74c3c';
        } else if (tank1.health < 60) {
            tank1HealthBar.style.backgroundColor = '#f39c12';
        } else {
            tank1HealthBar.style.backgroundColor = '#2ecc71';
        }
        
        if (tank2.health < 30) {
            tank2HealthBar.style.backgroundColor = '#e74c3c';
        } else if (tank2.health < 60) {
            tank2HealthBar.style.backgroundColor = '#f39c12';
        } else {
            tank2HealthBar.style.backgroundColor = '#e74c3c';
        }
    }
    
    function endGame(winnerId) {
        gameOver = true;
        
        // Show game over message
        gameMessage.textContent = `TANK ${winnerId} WINS!`;
        gameMessage.style.display = "block";
        
        // Show restart button
        restartButton.style.display = "block";
    }

    function gameLoop() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw grid and obstacles
        drawGrid();

        // Update tank movement
        if (!gameOver) {
            updateTankMovement(tank1, { w: keys.w, a: keys.a, s: keys.s, d: keys.d });
            updateTankMovement(tank2, { w: keys.ArrowUp, a: keys.ArrowLeft, s: keys.ArrowDown, d: keys.ArrowRight });

            // Handle shooting
            if (keys[" "]) {
                shoot(tank1);
                keys[" "] = false;
            }

            if (keys.Enter) {
                shoot(tank2);
                keys.Enter = false;
            }
        }

        // Update game entities
        updateBullets();
        updateExplosions();

        // Update tank state
        if (tank1.flashCount > 0) tank1.flashCount--;
        if (tank2.flashCount > 0) tank2.flashCount--;

        if (tank1.shootCooldown > 0) tank1.shootCooldown--;
        if (tank2.shootCooldown > 0) tank2.shootCooldown--;

        // Draw game entities
        drawTank(tank1);
        drawTank(tank2);
        bullets.forEach(drawBullet);
        drawExplosions();

        // Continue game loop
        requestAnimationFrame(gameLoop);
    }

    // Initialize and start game
    initGame();
    gameLoop();
    
    // Handle window resize
    window.addEventListener('resize', () => {
        canvas.width = Math.min(window.innerWidth * 0.8, 1000);
        canvas.height = Math.min(window.innerHeight * 0.8, 700);
    });
</script>

</body>
</html>